// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
contract Crowdfund{
    // contract for each independent campaign -> will be generated by the factory
    address public owner; // owner of the campaign
    string public campaignName; // name of the campaign
    string public description; // description of the campaign
    string public image; // image of the campaign
    uint256 public target; // target fund of the campaign
    uint256 public deadline; // deadline of the campaign
    address[] public donators; // keep track of who donated
    mapping (address => uint) public donationAmounts; // track donate amount
    mapping (address => bool) public hasDonated; // for check if donator has already donated before -> for O(1) time of donate()

    // campaign states
    enum CampaignState {Active, Success, Fail}
    CampaignState public state; // to track state of camping -> for refund, rewards, and check status

    // voting states
    struct ExtensionProposal {
        uint256 proposedDays; // number of days want to extend the deadline
        uint256 votesFor; // number of vote yes
        uint256 votesAgainst; // number of vote no
        bool active; // track is proposal active or not
        mapping(address => bool) hasVoted; // track donator voted or not
    }

    ExtensionProposal public curProposal;
    uint256 public constant VOTING_PERIOD = 3 days;
    uint256 public voteEndTime;


    modifier campaignActive() {
        require(state == CampaignState.Active, "Campaign not open"); // campaign need to be active
        _;
    }

    modifier onlyOwner() {
        require(owner == msg.sender, "only owner");
        _;
    }

    // constructor
    constructor(address _owner, string memory _name, string memory _description, uint256 _target, uint256 _deadline, string memory _image
    ) {
        owner = _owner;
        campaignName = _name;
        description = _description;
        target = _target;
        deadline = _deadline;
        state = CampaignState.Active; // set active as defualt
        image = _image;
    }

    // function for check the campaign states and update them
    function refreshCampaignState() internal {

        // success
        if (address(this).balance >= target) {
            state = CampaignState.Success;
            return;
        }

        // fail
        if (block.timestamp > deadline ) {
            // passed deadline
            state = CampaignState.Fail;
        }
    }

    // donation to the campaign
    function donate() public payable campaignActive {
        require(msg.value > 0, "Must donate some ETH to donate"); // need donate sth
        require(!curProposal.active, "voting period now, cannot donate"); // cant donate when voting
        
        // record donation
        // check if donator is in list
        if (!hasDonated[msg.sender]) {
            donators.push(msg.sender); // add donator to the list
            hasDonated[msg.sender] = true; // mark as donator
        }

        // record the donation amount
        donationAmounts[msg.sender] += msg.value; // add donation amount in the list mapping

        // update the state of campaign
        refreshCampaignState();
    }


    // withdraw funds from the campaign (only the owner can withdraw funds and need to target)
    function withdraw() public onlyOwner{
        require(state == CampaignState.Success, "Campaign not met target");

        // balance of this contract (campaign collected funds)
        uint256 balance = address(this).balance;
        require(balance > 0, "No balance");

        // transfer balance to owner
        payable(owner).transfer(balance);
    }

    // see balance
    function getContractBalance() public view returns (uint256) {
        return address(this).balance;
    }
    
    // get state
    function getState() public view returns (CampaignState) {
        // refresh state (cant use the function (view only) -> it will update state)
        if(state == CampaignState.Active && block.timestamp > deadline){
            return address(this).balance >= target? CampaignState.Success : CampaignState.Fail;
        }
        return state;
    }

    // refund funds
    function refund() public {
        // when active -> update state
        if ( state == CampaignState.Active) {
            refreshCampaignState();
        }
        // not active -> success or fail -> no need check (less gas)
        require(state == CampaignState.Fail, "refund not avalible"); // need campaign then can refund them back
        require(hasDonated[msg.sender], "No fund to refund"); // check is a donater or not

        // has donated -> refund them
        uint256 amount = donationAmounts[msg.sender]; // get donated money donated by that person
        require(amount > 0, "nothing to refund");

        donationAmounts[msg.sender] = 0; // update donated amount
        payable(msg.sender).transfer(amount); // transfer money
    }

    // voting events
    event DeadlineExtensionProposed(uint256 _days, uint256 voteEndTime); // event to propose a deadline extension
    event Voted(address voterAddr, bool voteFor, uint256 voteAmount); // event of donator votes
    event DeadlineExtensionSuccess(uint256 deadline);
    event DeadlineExtensionFailed();

    // create proposal for deadline extension
    function proposeDeadlineExtension(uint256 _days) public onlyOwner campaignActive {
        require(!curProposal.active, "Another proposal is activating");
        require(_days > 0, "Invalid extension period");

        // delete previous proposal -> reset
        delete curProposal;
        // update the proposal of deadline
        curProposal.proposedDays = _days;
        curProposal.votesFor = 0;
        curProposal.votesAgainst = 0;
        curProposal.active = true;

        voteEndTime = block.timestamp + VOTING_PERIOD; // set voting end time

        emit DeadlineExtensionProposed(_days, voteEndTime); // emit event
    }

    // vote on deadline proposal extension
    // voting -> not 1 ppl 1 vote -> donate more -> more vote power
    function voteOnDeadlineExtension(bool _voteFor) public campaignActive {
        require(curProposal.active, "no proposal now"); // check for proposal activating before vote
        require(block.timestamp <= voteEndTime, "vote period ended"); // check for vote end time
        require(hasDonated[msg.sender], "non donator cant join voting"); // check for is donator vote
        require(!curProposal.hasVoted[msg.sender], "already voted"); // check for voted or not

        uint256 voteAmount = donationAmounts[msg.sender]; // votes = donations amount
        require(voteAmount > 0, "vote < 0"); // need > 0 votes

        // record voted
        curProposal.hasVoted[msg.sender] = true;

        // add vote to curProposal
        if (_voteFor) {
            curProposal.votesFor += voteAmount;
        } else {
            curProposal.votesAgainst += voteAmount;
        }

        emit Voted(msg.sender, _voteFor, voteAmount); // emit event
    }

    // confirm voting result
    function confirmDeadlineExtension() public campaignActive {
        require(curProposal.active, "no proposal now"); // check have any proposal to confirm
        require(block.timestamp > voteEndTime, "voting still ongoing"); // check is still voting

        // update the proposal
        curProposal.active = false;

        // decide result
        uint256 totalDonations = address(this).balance;
        // vote > 50% donation -> win
        // vote <= 50% donation -> lose
        // and no 0 division problems
        if(totalDonations > 0 && curProposal.votesFor > totalDonations/2) {
            deadline += curProposal.proposedDays * 1 days;
            emit DeadlineExtensionSuccess(deadline);
        } else {
            emit DeadlineExtensionFailed();
        }

        // reset proposal
        delete curProposal;
        voteEndTime = 0;
    }
}
contract CrowdfundFactory {

    address public owner;
    bool public pause;

    // campiagn
    struct Campaign {
        address campaignAddress;
        address owner;
        string name;
        uint256 createTime;
    }

    Campaign[] public campaigns; // list of campaigns that has created
    mapping(address => Campaign[]) public userCampaigns; // mappings for address of the corresponding 

    event CampaignCreated(address indexed campaignAddress, address indexed owner, string name);

    // constructor to construct the factory
    constructor() {
        owner = msg.sender;
    }

    // create campaign
    function createCampaign(string memory _name, string memory _description, uint256 _target, uint256 _deadline, string memory _image) external whenNotPaused {
        // input validation
        require(bytes(_name).length > 0, "name is empty");
        require(_target > 0, "target must > 0");
        require(_deadline > block.timestamp, "deadline must be in the future");

        // create a new contract for the new campaign
        Crowdfund newCampaign = new Crowdfund(
            msg.sender,
            _name,
            _description,
            _target,
            _deadline,
            _image
        );

        address campaignAddr = address(newCampaign); // address of the campaign contract that created

        // make a sturct for the context of that campaign
        Campaign memory campaign = Campaign({
            campaignAddress: campaignAddr,
            owner: msg.sender,
            name: _name,
            createTime: block.timestamp
        });

        campaigns.push(campaign); // add to the campaign list
        userCampaigns[msg.sender].push(campaign); // map the campaign of this address to the current context

        // emit to signal ui campaign is created
        emit CampaignCreated(campaignAddr, msg.sender, _name);
    }

    modifier onlyOwner() {
        require(owner == msg.sender, "only owner");
        _;
    }

    modifier whenNotPaused() {
        require(!pause , "it is paused");
        _;
    }

    // getter: get user campaigns list
    function getUserCampaigns(address userAddr) external view returns (Campaign[] memory){
        return userCampaigns[userAddr]; // return the campaign list of that user
    }

    // getter : get all campaigns
    function getAllCampaigns() external view returns (Campaign[] memory){
        return campaigns; 
    }

    // toggle pause function using the library
    function togglePause() public onlyOwner {
        pause = !pause;
    }
}