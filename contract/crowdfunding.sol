// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract Crowdfund is ReentrancyGuard{
    // contract for each independent campaign -> will be generated by the factory
    address public owner; // owner of the campaign
    string public campaignName; // name of the campaign
    string public description; // description of the campaign
    string public image; // image of the campaign
    uint256 public target; // target fund of the campaign
    uint256 public deadline; // deadline of the campaign
    uint256 public totalDonations; // keep track of the total funds collected
    address[] public donators; // keep track of who donated
    mapping (address => uint) public donationAmounts; // track donate amount
    mapping (address => bool) public hasDonated; // for check if donator has already donated before -> for O(1) time of donate()

    // campaign states
    enum CampaignState {Active, Success, Fail}
    CampaignState public state; // to track state of camping -> for refund, rewards, and check status

    // voting states
    struct ExtensionProposal {
        uint256 proposedDays; // number of days want to extend the deadline
        uint256 votesFor; // number of vote yes
        uint256 votesAgainst; // number of vote no
        bool active; // track is proposal active or not
        mapping(address => bool) hasVoted; // track donator voted or not
    }

    ExtensionProposal public curProposal;
    uint256 public constant VOTING_PERIOD = 3 days;
    uint256 public voteEndTime;


    modifier campaignActive() {
        require(state == CampaignState.Active, "Campaign not open"); // campaign need to be active
        _;
    }

    modifier onlyOwner() {
        require(owner == msg.sender, "only owner");
        _;
    }

    // constructor
    constructor(address _owner, string memory _name, string memory _description, uint256 _target, uint256 _deadline, string memory _image
    ) {
        require(bytes(_name).length > 0, "name is empty");
        require(_target > 0, "target must > 0");
        require(_deadline > block.timestamp, "deadline must be in the future");


        owner = _owner;
        campaignName = _name;
        description = _description;
        target = _target;
        deadline = _deadline;
        state = CampaignState.Active; // set active as defualt
        image = _image;
    }

    // function for check the campaign states and update them
    function refreshCampaignState() internal {

        // success
        if (totalDonations >= target) {
            state = CampaignState.Success;
            return;
        }

        // fail
        if (block.timestamp > deadline ) {
            // passed deadline
            state = CampaignState.Fail;
        }
    }

    // donation to the campaign
    function donate() public payable campaignActive {
        require(msg.value > 0, "Must donate some ETH to donate"); // need donate sth
        require(!curProposal.active, "voting period now, cannot donate"); // cant donate when voting
        
        // record donation
        // check if donator is in list
        if (!hasDonated[msg.sender]) {
            donators.push(msg.sender); // add donator to the list
            hasDonated[msg.sender] = true; // mark as donator
        }

        // record the donation amount
        donationAmounts[msg.sender] += msg.value; // add donation amount in the list mapping
        totalDonations += msg.value;

        // update the state of campaign
        refreshCampaignState();
    }


    // withdraw funds from the campaign (only the owner can withdraw funds and need to target)
    function withdraw() public onlyOwner nonReentrant {
        refreshCampaignState(); // to refresh state of Campaign
        require(state == CampaignState.Success, "Campaign not met target");

        // balance of this contract (campaign collected funds)
        uint256 balance = address(this).balance;
        require(balance > 0, "No balance");

        // transfer balance to owner
        payable(owner).transfer(balance);
    }

    // see balance of the contract (not for tracking the total dontations)
    function getContractBalance() public view returns (uint256) {
        return address(this).balance;
    }
    
    // get state
    function getState() public view returns (CampaignState) {
        // refresh state (cant use the function (view only) -> it will update state)
        if(state == CampaignState.Active && block.timestamp > deadline){
            return totalDonations >= target? CampaignState.Success : CampaignState.Fail;
        }
        return state;
    }

    // refund funds
    function refund() public nonReentrant {
        // when active -> update state
        if ( state == CampaignState.Active) {
            refreshCampaignState();
        }
        // not active -> success or fail -> no need check (less gas)
        require(state == CampaignState.Fail, "refund not avalible"); // need campaign then can refund them back
        require(hasDonated[msg.sender], "No fund to refund"); // check is a donater or not

        // has donated -> refund them
        uint256 amount = donationAmounts[msg.sender]; // get donated money donated by that person
        require(amount > 0, "nothing to refund");

        donationAmounts[msg.sender] = 0; // update donated amount
        payable(msg.sender).transfer(amount); // transfer money
    }

    // voting events
    event DeadlineExtensionProposed(uint256 _days, uint256 voteEndTime); // event to propose a deadline extension
    event Voted(address voterAddr, bool voteFor, uint256 voteAmount); // event of donator votes
    event DeadlineExtensionSuccess(uint256 deadline);
    event DeadlineExtensionFailed();

    // create proposal for deadline extension
    function proposeDeadlineExtension(uint256 _days) public onlyOwner campaignActive {
        require(!curProposal.active, "Another proposal is activating");
        require(_days > 0, "Invalid extension period");
        require(totalDonations * 2 >= target, "Need >= 50% target to propose extension");

        // delete previous proposal -> reset
        delete curProposal;
        // update the proposal of deadline
        curProposal.proposedDays = _days;
        curProposal.votesFor = 0;
        curProposal.votesAgainst = 0;
        curProposal.active = true;

        voteEndTime = block.timestamp + VOTING_PERIOD; // set voting end time

        emit DeadlineExtensionProposed(_days, voteEndTime); // emit event
    }

    // vote on deadline proposal extension
    // voting -> not 1 ppl 1 vote -> donate more -> more vote power
    function voteOnDeadlineExtension(bool _voteFor) public campaignActive {
        require(curProposal.active, "no proposal now"); // check for proposal activating before vote
        require(block.timestamp <= voteEndTime, "vote period ended"); // check for vote end time
        require(hasDonated[msg.sender], "non donator cant join voting"); // check for is donator vote
        require(!curProposal.hasVoted[msg.sender], "already voted"); // check for voted or not

        uint256 voteAmount = donationAmounts[msg.sender]; // votes = donations amount
        require(voteAmount > 0, "vote < 0"); // need > 0 votes

        // record voted
        curProposal.hasVoted[msg.sender] = true;

        // add vote to curProposal
        if (_voteFor) {
            curProposal.votesFor += voteAmount;
        } else {
            curProposal.votesAgainst += voteAmount;
        }

        emit Voted(msg.sender, _voteFor, voteAmount); // emit event
    }

    // confirm voting result
    function confirmDeadlineExtension() public campaignActive {
        require(curProposal.active, "no proposal now"); // check have any proposal to confirm
        require(block.timestamp > voteEndTime, "voting still ongoing"); // check is still voting

        // update the proposal
        curProposal.active = false;

        // vote > 50% donation -> win
        // vote <= 50% donation -> lose
        // and no 0 division problems
        // votesFor > totalDonation/2
        // == voteFor * 2 > totalDonations <- avoid division and int overflow
        if(totalDonations > 0 && curProposal.votesFor * 2 > totalDonations) {
            deadline += curProposal.proposedDays * 1 days;
            emit DeadlineExtensionSuccess(deadline);
        } else {
            emit DeadlineExtensionFailed();
        }

        // reset proposal
        delete curProposal;
        voteEndTime = 0;
    }
}